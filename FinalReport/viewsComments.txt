#   The view for schedule.html
#   once the user has logged in
#   database is queried for all
#   the events associated with
#   that user's id.
#   The function calculates the
#   absolute position for the colored
#   square for each event and the height
#   for each square for display on the
#   user's schedule. The function also
#   assigns each event a different
#   random color. Each event is put
#   into a dictionary with the event
#   as a key and an array corresponding
#   to the top, height, and color
#   of the square as the value.
#   This dictionary is passed as a
#   context to the schedule.html
#   template which is returned to the
#   webrowser as an HTTPresponse
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def schedule(request):

#   The view for add.html. This
#   view function is a little more
#   complicated because it sometimes
#   a 'Search' parameter as part
#   of the passed request. It also
#   uses python regexes to check
#   the request against formats
#   such as EECS 337 or EECS341, that
#   way we can query on the proper
#   event attributes. Finally, after
#   finding the querySet for the passed
#   search parameter, we create a dictionary
#   with each event as a key. Then, we run
#   through all of the results and check to see
#   if the current user is enrolled in that event.
#   If so we set the value for that event's key
#   in our dict to the corresponding boolean value.
#   This dictionary is passed as a
#   context to the add.html
#   template which is returned to the
#   webrowser as an HTTPresponse
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def add(request):

#   The info view is called whenever
#   the user clicks on a meeting-time's
#   name. The function is passed a
#   request with a query string containing
#   the desired course's department and
#   course number. We perform a query search
#   on the Instructs relation to find all
#   classes that match the passed dept and
#   number combination (or at least contain
#   those strings). Then we perform the same
#   search throught the enrollment table
#   to find classes the user is already enrolled
#   in as we did in the add view.
#   This dictionary is passed as a
#   context to the add.html
#   template which is returned to the
#   webrowser as an HTTPresponse
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def info(request):

#   The instructor view is the view
#   function for the instructor.html.
#   page. This function expects to be
#   sent an 'instructor' query string
#   with the name of the 'clicked-on'
#   instructor. We query the instructor
#   table for the instructor with that name
#   and send that instructor as a context
#   to the instructor.html template, and
#   that html file is returned as a
#   HTTPresponse page
#   See https://docs.djangoproject.com/en/dev/topics/http/views/s
def instructor(request):

#   The inscourse view is a temporary view
#   that redirects the user back to the
#   add.html page. However, the query we
#   have to perform is slightly different,
#   thus neccessitating an entirely new view.
#   Here we are passed an instructor name
#   as part of the request. We query the
#   Instructs table for all of the tuples
#   whose instructor's name matched the
#   name query string. We then perform
#   the same filter from add where
#   we check to see which of the courses
#   from the first queryset the user is enrolled
#   in. We create a dictionary of classes to booleans
#   and pass that as a context to the add.html template
#   and return as a HttpResponse
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def inscourse(request):

#   The insearch view is the view function
#   for the insearch.html page. This view
#   can take in a name query string but does
#   not neccessarily expect it. If there is
#   a valid name query string, we query the
#   intructor table for all of the instructors
#   whose name or email contains the query
#   string. We then send that query set as a
#   context to the 'inssearch.html' template
#   file which is then returned as a
#   HttpResponse
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def inssearch(request):

#   The addcourse is a temporary view
#   that is called when a user click
#   an 'add course' button. The view
#   expects a request containing an
#   'eventId' string representing the
#   id of the event the user is trying
#   to add and an 'id' query string that
#   is the id of the current user. We then
#   create a new enroll tuple with the
#   student's id and the event's id
#   as the two foreign keys. Then we
#   redirect the application to the
#   scheduler page with a
#   HttpResponseRedirect
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def addcourse(request):

#   The removecourse is a temporary view
#   that is called when a user click
#   an 'remove course' button. The view
#   expects a request containing an
#   'eventId' string representing the
#   id of the event the user is trying
#   to remove and an 'id' query string that
#   is the id of the current user. We then
#   query the enroll table for the tuple
#   ith the user's id as the event's id
#   as the query parameters and delete
#   the resulting tupe. Then we
#   redirect the application to the
#   scheduler page with a
#   HttpResponseRedirect
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def removecourse(request):

#   The mycourses view function is another
#   view function for the add.html page.
#   Unlike the other two, this function
#   immediately finds all of the courses
#   that the current user is enrolled in
#   and sends that dictionary as a context
#   to add.html
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def mycourses(request):

#   The customevent view function is the view
#   for the custom.html field. If the event
#   is passed a request with a POST method,
#   ie the user hit a submit button, then
#   the view all of the query strings and,
#   if the strings are valid (see below),
#   we create a new entry in the customevent
#   table with the query strings set as the
#   corresponding attributes. Then we create
#   a new enrollment table entry linking the
#   current user to the newly created custom
#   event. Then we return a HttpResponseRedirect
#   to the home page If this view is called without
#   a POST request method, then we simply
#   pass the custom.html template
#   an empty instance of an EventForm
#   (see below) and return the rendered
#   custom.html page as a HttpResponse.
#   See https://docs.djangoproject.com/en/dev/topics/http/views/
def customevent(request):

#   The EventForm class is a simple
#   instance of a forms.Form. Every
#   field we want the user to supply
#   data for is set an a member attribute
#   of this class. Two of the fields, location
#   and days, are given their own custom validators
#   since we allow any chars to be entered but we
#   want those strings to have a certain form, eg
#   MWF is valid for days but CANDV is not.
#   See https://docs.djangoproject.com/en/dev/topics/forms/?from=olddocs
class EventForm(forms.Form):

#   This function is the validation function for
#   the times field in EventForm. It uses regexes
#   to check that the user's passed time is in a form
#   such as 9:00am-10:00 pm. If the times input does not
#   match the regex, or if the end date is before
#   the start date, we raise a validationError,
#   which refuses the user's submission
#   and supplies the appropriate error message.
#   See https://docs.djangoproject.com/en/dev/ref/validators/
def validate_time(value):

#   This function is the validation function for
#   the days field in EventForm. It uses regexes
#   to check that the user's passed days is in a form
#   such as MWF or FSu. If the days input does not
#   match the regex, we raise a validationError,
#   which refuses the user's submission
#   and supplies the appropriate error message.
#   See https://docs.djangoproject.com/en/dev/ref/validators/
def validate_day(value):

#   The parse_time function
#   is a helper function that
#   takes in an array whose
#   first index is a start time
#   and whose second index is
#   an end time. It then converts
#   those strings to python datetime.time
#   objects and returns two arrays, one
#   for the converted starttime and one
#   for the converted endtime
def parse_time(array):